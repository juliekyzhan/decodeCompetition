payroll_industry_pl_raw + payroll_industry_ne_raw +
party_value_pl_raw + party_value_ne_raw +
party_score_pl_raw + party_score_ne_raw +
employ_industry_pl_raw + employ_industry_ne_raw +
(1|issue) + (1|full_name) + (1|congress))
formula_domprof <- bf(label ~ committee_pl_raw + committee_ne_raw +  ethnicity_pl_raw + ethnicity_ne_raw +
payroll_industry_pl_raw + payroll_industry_ne_raw +
party_value_pl_raw + party_value_ne_raw +
party_score_pl_raw + party_score_ne_raw +
employ_industry_pl_raw + employ_industry_ne_raw +
(1|issue) + (1|full_name) + (1|congress))
formula_intlprof <- bf(label ~ leverage_pl_raw + leverage_ne_raw + committee_pl_raw + committee_ne_raw +
(1|issue) + (1|full_name) + (1|congress))
formula_match <- bf(
as.formula(paste("label ~", paste(match_features, collapse = " + "), "+ (1|issue) + (1|full_name) + (1|congress)"))
)
#| label: discriminant prior setting
#| echo: false
#| message: true
#| warning: true
# keep prior_base
prior_base <- c(
set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
set_prior("student_t(3, 0, 2.5)", class = "sd")
)
# change prior_raw/match into prior_mechanism
prior_mechanism <- c(
set_prior("normal(0, 2.5)", class = "b"),
set_prior("student_t(3, 0, 2.5)", class = "Intercept"),
set_prior("student_t(3, 0, 2.5)", class = "sd")
)
#| label: variables importance comparison function
#| echo: false
#| message: true
#| warning: true
# ==== Function: bayes_value_importance_v2() ====
# this section defines a function visualize and export posterior fixed effect estimates from bayes model
# - 1. ranks predictions by absolute logit coefficient
# - 2. plots estimates with 95% ci
# - 3. optionally saves the plot and the table to disk
bayes_value_importance_v2 <- function(model, model_name = "Model",
save_dir = file.path(output_dir, "bayes_value_importance"),
save_plot = TRUE, save_table = TRUE) {
if (!dir.exists(save_dir)) dir.create(save_dir, recursive = TRUE)
effects <- as.data.frame(fixef(model)) %>%
tibble::rownames_to_column("Variable") %>%
dplyr::filter(!(Variable %in% c("(Intercept)", "Intercept"))) %>%
dplyr::arrange(desc(abs(Estimate)))
p <- ggplot(effects, aes(x = reorder(Variable, abs(Estimate)), y = Estimate)) +
geom_col(fill = "skyblue") +
geom_errorbar(aes(ymin = Q2.5, ymax = Q97.5), width = 0.2) +
coord_flip() +
labs(
title = paste("Posterior Estimates (with 95% CI) -", model_name),
x = NULL, y = "Logit Coefficient"
) +
theme_minimal(base_size = 13)
if (save_plot) {
plot_path <- file.path(save_dir, paste0("bayes_coef_plot_", model_name, ".png"))
ggsave(plot_path, p, width = 7, height = 5)
message(glue::glue("‚úÖ plot saves to: {plot_path}"))
}
if (save_table) {
table_path <- file.path(save_dir, paste0("bayes_coef_table_", model_name, ".csv"))
readr::write_csv(effects, table_path)
message(glue::glue("üìÑ tables saves to: {table_path}"))
}
return(list(plot = p, data = effects))
}
#| label: shap values comparison function debug
#| echo: false
#| message: true
#| warning: true
debug_once(compare_bayes_vs_shap_data)
#| label: shap values comparison function1
#| echo: false
#| message: true
#| warning: true
# ==== Function 1: Extract & Match Coefficients with SHAP ====
compare_bayes_vs_shap_data <- function(
bayes_model,
shap_data,
set_name = "test",
match_vars = NULL,
suffix = "_raw"
) {
coef_bayes <- fixef(bayes_model)[, "Estimate"]
coef_names <- setdiff(names(coef_bayes), c("(Intercept)", "Intercept"))
# --- 1. Ëá™Âä®ÂåπÈÖçÂêéÁºÄ ---
if (!is.null(match_vars)) {
match_vars_with_suffix <- paste0(match_vars, suffix)
vars_in_model <- intersect(coef_names, match_vars_with_suffix)
if (length(vars_in_model) == 0) {
vars_in_model <- intersect(coef_names, match_vars)
}
} else {
vars_in_model <- coef_names
}
if (length(vars_in_model) == 0) {
stop("No matched variables found in Bayesian model. Please check match_vars and suffix.")
}
coef_bayes_tbl <- tibble::tibble(
var = vars_in_model,
coef_logit = coef_bayes[vars_in_model],
var_clean = stringr::str_remove(vars_in_model, paste0(suffix, "$"))
)
# --- 2. Á°Æ‰øù shap_data Êúâ set Âàó ---
if (!"set" %in% names(shap_data)) shap_data$set <- set_name
vars_shap <- coef_bayes_tbl$var_clean
missing_vars <- setdiff(vars_shap, colnames(shap_data))
if (length(missing_vars) > 0) {
warning(glue::glue("‚ö†Ô∏è Missing vars in shap_data: {paste(missing_vars, collapse = ', ')}"))
vars_shap <- setdiff(vars_shap, missing_vars)
}
shap_values <- shap_data %>%
dplyr::filter(.data$set == set_name) %>%
dplyr::summarise(dplyr::across(all_of(vars_shap), mean, na.rm = TRUE)) %>%
tidyr::pivot_longer(cols = everything(), names_to = "shap_var", values_to = "shap_value")
comparison <- coef_bayes_tbl %>%
dplyr::left_join(shap_values, by = c("var_clean" = "shap_var")) %>%
dplyr::mutate(
dir_logit = sign(coef_logit),
dir_shap = dplyr::if_else(shap_value == 0, NA, sign(shap_value)),
abs_coef_logit = abs(coef_logit),
abs_shap_value = abs(shap_value),
direction_match = (dir_logit == dir_shap)
)
summary_stats <- tibble::tibble(
Direction_Match_Rate = mean(comparison$direction_match, na.rm = TRUE),
Pearson_Correlation = cor(comparison$coef_logit, comparison$shap_value, use = "complete.obs"),
Abs_Value_Correlation = cor(comparison$abs_coef_logit, comparison$abs_shap_value, use = "complete.obs")
)
return(list(summary = summary_stats, detail = comparison))
}
#| label: shap values comparison function3
#| echo: false
#| message: true
#| warning: true
# ==== Function 3: Run batch comparisons safely ====
run_bayes_shap_all_models <- function(model_list, shap_data, match_vars, set_name = "test", suffix = "_raw") {
purrr::imap(model_list, ~{
tryCatch({
result <- compare_bayes_vs_shap_data(
bayes_model = .x,
shap_data   = shap_data,
set_name    = set_name,
match_vars  = match_vars,
suffix      = suffix
)
result$plot <- plot_bayes_vs_shap(result$detail, model_name = .y)
result
}, error = function(e) {
message(glue::glue("‚ùå Model {.y} error: {e$message}"))
return(NULL)
})
}) %>% purrr::compact()
}
#| label: adver_discriminant model training
#| echo: false
#| message: true
#| warning: true
# ----- model training ----
bayes_base <- brm(formula_base, data = train_data_adver, family = bernoulli(),
prior = prior_base, iter = 1000, chains = 2, seed = 123)
bayes_intl <- brm(formula_intl, data = train_data_adver, family = bernoulli(),
prior = prior_mechanism, iter = 1000, chains = 2, seed = 123)
bayes_intldom <- brm(formula_intldom, data = train_data_adver, family = bernoulli(),
prior = prior_mechanism, iter = 1000, chains = 2, seed = 123)
bayes_domprof <- brm(formula_domprof, data = train_data_adver, family = bernoulli(),
prior = prior_mechanism, iter = 1000, chains = 2, seed = 123)
bayes_intlprof <- brm(formula_intlprof, data = train_data_adver, family = bernoulli(),
prior = prior_mechanism, iter = 1000, chains = 2, seed = 123)
bayes_match <- brm(formula_match, data = train_data_adver, family = bernoulli(),
prior = prior_mechanism, iter = 1000, chains = 2, seed = 123)
#| label: adver_discriminant results
#| echo: false
#| message: true
#| warning: true
# ----- loo comparsion -----
loo_base <- loo(bayes_base)
loo_intl <- loo(bayes_intl)
loo_intldom  <- loo(bayes_intldom)
loo_domprof <- loo(bayes_domprof)
loo_intlprof <- loo(bayes_intlprof)
loo_match <- loo(bayes_match)
loo_intl$estimates["elpd_loo", "Estimate"]
loo_intldom$estimates["elpd_loo", "Estimate"]
loo_domprof$estimates["elpd_loo", "Estimate"]
loo_intlprof$estimates["elpd_loo", "Estimate"]
loo_match$estimates["elpd_loo", "Estimate"]
# tables compares loo
loo_compare_mechanism <- loo_compare(loo_base, loo_intl, loo_intldom, loo_domprof, loo_intlprof, loo_match)
print(loo_compare_mechanism)
# visualization loo comparison
plot(loo_compare_mechanism, label_points = TRUE, main = "Bayesian Mechanism Models: LOOIC Comparison")
# ----- bayes r2 -----
r2_mechanism_models_bayes <- tibble::tibble(
Model = c("BASE", "INTL", "INTLDOM", "DOMPROF", "INTLPROF", "ALL"),
Pseudo_R2 = c(bayes_r2_brms(bayes_base),
bayes_r2_brms(bayes_intl),
bayes_r2_brms(bayes_intldom),
bayes_r2_brms(bayes_domprof),
bayes_r2_brms(bayes_intlprof),
bayes_r2_brms(bayes_match))
)
# 5. tables outprint
knitr::kable(r2_mechanism_models_bayes, caption = "Bayesian Pseudo R¬≤ Comparison (Mechanism Models)")
#| label: adver_discriminant variables importance comparison
#| echo: false
#| message: true
#| warning: true
base_result     <- bayes_value_importance_v2(bayes_base, model_name = "BASE")
intl_result     <- bayes_value_importance_v2(bayes_intl, model_name = "INTL")
intldom_result  <- bayes_value_importance_v2(bayes_intldom, model_name = "INTLDOM")
domprof_result  <- bayes_value_importance_v2(bayes_domprof, model_name = "DOMPROF")
intlprof_result <- bayes_value_importance_v2(bayes_intlprof, model_name = "INTLPROF")
match_result    <- bayes_value_importance_v2(bayes_match, model_name = "MATCH")
#| label: adver_discriminant with shap values adver
#| echo: false
#| message: true
#| warning: true
model_list <- list(
BASE      = bayes_base,
INTL      = bayes_intl,
INTLDOM   = bayes_intldom,
DOMPROF   = bayes_domprof,
INTLPROF  = bayes_intlprof,
MATCH     = bayes_match
)
results_adver <- run_bayes_shap_all_models(model_list, adver_all, match_vars, suffix = "")
summary_adver_shap <- purrr::imap_dfr(results_adver, ~ tibble::tibble(
Model = .y,
Direction_Match_Rate = .x$summary$Direction_Match_Rate,
Pearson_Correlation   = .x$summary$Pearson_Correlation,
Abs_Correlation       = .x$summary$Abs_Value_Correlation
))
print(summary_adver_shap)
# ----- debug -----
names(bayes_base$data)
print(match_vars)
print(paste0(match_vars, suffix))
#| label: adver_discriminant with shap values adver
#| echo: false
#| message: true
#| warning: true
model_list <- list(
BASE      = bayes_base,
INTL      = bayes_intl,
INTLDOM   = bayes_intldom,
DOMPROF   = bayes_domprof,
INTLPROF  = bayes_intlprof,
MATCH     = bayes_match
)
results_adver <- run_bayes_shap_all_models(model_list, adver_all, match_vars, suffix = "")
summary_adver_shap <- purrr::imap_dfr(results_adver, ~ tibble::tibble(
Model = .y,
Direction_Match_Rate = .x$summary$Direction_Match_Rate,
Pearson_Correlation   = .x$summary$Pearson_Correlation,
Abs_Correlation       = .x$summary$Abs_Value_Correlation
))
print(summary_adver_shap)
# ----- debug -----
cat("---- VAR CHECK ----\n")
print(coef_names)
cat("---- VAR CHECK ----\n")
coef_names <- names(fixef(bayes_match)[, "Estimate"])
print(coef_names)
print(match_vars)
print(intersect(coef_names, match_vars))
#| label: shap values comparison function1
#| echo: false
#| message: true
#| warning: true
# ==== Function 1: Extract & Match Coefficients with SHAP (robust version) ====
compare_bayes_vs_shap_data <- function(
bayes_model,
shap_data,
set_name = "test",
match_vars = NULL,
suffix = "_raw"
) {
# 1. extract coef names from brms model
coef_bayes <- fixef(bayes_model)[, "Estimate"]
coef_names <- setdiff(names(coef_bayes), c("(Intercept)", "Intercept"))
# 2. build matching list of coef names (fuzzy matching to capture dummy expansions)
if (!is.null(match_vars)) {
vars_in_model <- character(0)
for (mv in match_vars) {
# try patterns: with suffix (e.g. leverage_pl_raw) and without suffix (leverage_pl)
pat1 <- paste0("^", mv, suffix)   # e.g. ^leverage_pl_raw
pat2 <- paste0("^", mv)           # e.g. ^leverage_pl
matched <- coef_names[grepl(paste0(pat1, "|", pat2), coef_names)]
if (length(matched) > 0) {
vars_in_model <- c(vars_in_model, matched)
}
}
vars_in_model <- unique(vars_in_model)
} else {
vars_in_model <- coef_names
}
if (length(vars_in_model) == 0) {
stop("No matched variables found in Bayesian model. Please check match_vars and suffix.")
}
# 3. construct table mapping each matched coef name back to its base variable (var_clean)
#    e.g. leverage_pl_raw1 -> leverage_pl
map_var_to_base <- function(coef_name, match_vars, suffix) {
# remove trailing numeric indexes and optional suffix to recover base name
base <- coef_name
base <- stringr::str_remove(base, paste0(suffix, "[0-9]*$"))   # drop _raw1/_raw2/_raw etc
base <- stringr::str_remove(base, "[0-9]+$")                  # drop trailing digits (safety)
# if still not matching, try to find the match_var that is prefix
hit <- match_vars[vapply(match_vars, function(mv) grepl(paste0("^", mv), base), logical(1))]
if (length(hit) >= 1) {
return(hit[1])
} else {
# fallback: drop numeric suffix after last underscore
return(stringr::str_remove(base, "_[0-9]+$"))
}
}
var_clean_vec <- vapply(vars_in_model, map_var_to_base, FUN.VALUE = character(1), match_vars = match_vars, suffix = suffix)
coef_bayes_tbl <- tibble::tibble(
var = vars_in_model,
coef_logit = as.numeric(coef_bayes[vars_in_model]),
var_clean = var_clean_vec
)
# 4. aggregate coefficients per var_clean (Âπ≥ÂùáÂåñÂêÑ‰∏™ dummy ÁöÑÁ≥ªÊï∞)
coef_bayes_agg <- coef_bayes_tbl %>%
dplyr::group_by(var_clean) %>%
dplyr::summarise(
coef_logit = mean(coef_logit, na.rm = TRUE),
n_coefs = dplyr::n(),
.groups = "drop"
)
# 5. ensure shap_data has 'set' column
if (!"set" %in% names(shap_data)) shap_data$set <- set_name
# 6. prepare shap variables list (should correspond to var_clean)
vars_shap <- unique(coef_bayes_agg$var_clean)
missing_vars <- setdiff(vars_shap, colnames(shap_data))
if (length(missing_vars) > 0) {
warning(glue::glue("‚ö†Ô∏è Missing vars in shap_data and will be skipped: {paste(missing_vars, collapse = ', ')}"))
vars_shap <- setdiff(vars_shap, missing_vars)
coef_bayes_agg <- coef_bayes_agg %>% filter(var_clean %in% vars_shap)
}
if (length(vars_shap) == 0) {
stop("After checking shap_data, no overlapping variables remain for comparison.")
}
# 7. compute mean SHAP per variable (use new across lambda syntax to avoid deprecation warnings)
shap_values <- shap_data %>%
dplyr::filter(.data$set == set_name) %>%
dplyr::summarise(dplyr::across(all_of(vars_shap), \(x) mean(x, na.rm = TRUE))) %>%
tidyr::pivot_longer(cols = everything(), names_to = "shap_var", values_to = "shap_value")
# 8. combine aggregated bayes coefs with shap means
comparison <- coef_bayes_agg %>%
dplyr::left_join(shap_values, by = c("var_clean" = "shap_var")) %>%
dplyr::mutate(
abs_coef_logit = abs(coef_logit),
abs_shap_value = abs(shap_value),
dir_logit = sign(coef_logit),
dir_shap = dplyr::if_else(shap_value == 0, NA_real_, sign(shap_value)),
direction_match = (dir_logit == dir_shap),
direction_mismatch = ifelse(is.na(direction_match), NA, !direction_match)
)
# 9. summary statistics (handle possible NA in correlations)
pearson_cor <- tryCatch(cor(comparison$coef_logit, comparison$shap_value, use = "complete.obs"), error = function(e) NA_real_)
abs_cor <- tryCatch(cor(comparison$abs_coef_logit, comparison$abs_shap_value, use = "complete.obs"), error = function(e) NA_real_)
summary_stats <- tibble::tibble(
Direction_Match_Rate = mean(comparison$direction_match, na.rm = TRUE),
Pearson_Correlation = pearson_cor,
Abs_Value_Correlation = abs_cor
)
return(list(summary = summary_stats, detail = comparison))
}
#| label: shap values comparison function2
#| echo: false
#| message: true
#| warning: true
# ==== Function 2: Plot SHAP vs Coefficients (adjusted) ====
plot_bayes_vs_shap <- function(comparison_df, model_name = NULL) {
# ensure expected cols exist
if (!all(c("coef_logit", "shap_value", "var_clean", "abs_shap_value", "direction_mismatch") %in% colnames(comparison_df))) {
stop("comparison_df must contain columns: coef_logit, shap_value, var_clean, abs_shap_value, direction_mismatch")
}
p <- ggplot2::ggplot(comparison_df, ggplot2::aes(x = coef_logit, y = shap_value, label = var_clean)) +
ggplot2::geom_point(ggplot2::aes(color = abs_shap_value, shape = direction_mismatch), size = 3) +
ggplot2::geom_text(vjust = -0.8, size = 3) +
ggplot2::scale_color_gradient(low = "orange", high = "red", name = "Mean |SHAP|") +
ggplot2::scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 17), labels = c("Match", "Mismatch"), name = "Direction Match") +
ggplot2::geom_vline(xintercept = 0, linetype = "dashed", color = "gray60") +
ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "gray60") +
ggplot2::labs(
x = "Posterior Mean (Bayesian logit)",
y = "Average SHAP Value (LGBM)",
title = paste("SHAP vs Bayesian Coefficient Directions", ifelse(is.null(model_name), "", paste0(" - ", model_name)))
) +
ggplot2::theme_minimal()
return(p)
}
#| label: shap values comparison function3
#| echo: false
#| message: true
#| warning: true
# ==== Function 3: Run batch comparisons safely (unchanged interface) ====
run_bayes_shap_all_models <- function(model_list, shap_data, match_vars, set_name = "test", suffix = "_raw") {
purrr::imap(model_list, ~{
tryCatch({
result <- compare_bayes_vs_shap_data(
bayes_model = .x,
shap_data   = shap_data,
set_name    = set_name,
match_vars  = match_vars,
suffix      = suffix
)
result$plot <- plot_bayes_vs_shap(result$detail, model_name = .y)
result
}, error = function(e) {
message(glue::glue("‚ùå Model {.y} error: {e$message}"))
return(NULL)
})
}) %>% purrr::compact()
}
#| label: adver_discriminant with shap values adver
#| echo: false
#| message: true
#| warning: true
model_list <- list(
BASE      = bayes_base,
INTL      = bayes_intl,
INTLDOM   = bayes_intldom,
DOMPROF   = bayes_domprof,
INTLPROF  = bayes_intlprof,
MATCH     = bayes_match
)
results_adver <- run_bayes_shap_all_models(model_list, adver_all, match_vars, suffix = "")
summary_adver_shap <- purrr::imap_dfr(results_adver, ~ tibble::tibble(
Model = .y,
Direction_Match_Rate = .x$summary$Direction_Match_Rate,
Pearson_Correlation   = .x$summary$Pearson_Correlation,
Abs_Correlation       = .x$summary$Abs_Value_Correlation
))
print(summary_adver_shap)
#| label: adver_discriminant with shap values adver debug
#| echo: false
#| message: true
#| warning: true
# ËøêË°åÂâçÁ°Æ‰øù‰Ω†Â∑≤ÁªèÂä†ËΩΩ brms (fixef) Âπ∂ÂÆö‰πâÂ•Ω‰∫Ü model_list, match_vars, suffix
diagnose_models <- function(model_list, match_vars, suffix = "_raw") {
out <- list()
for (nm in names(model_list)) {
mod <- model_list[[nm]]
cat("\n---- MODEL:", nm, "----\n")
coef_b <- tryCatch(names(fixef(mod)[, "Estimate"]), error = function(e) NULL)
print(head(coef_b, 30))
if (is.null(coef_b)) {
cat("  >> cannot extract fixef() names (model type mismatch?)\n")
out[[nm]] <- list(coef_names = NA_character_, matched = character(0))
next
}
# exact intersections
inter1 <- intersect(coef_b, match_vars)
inter2 <- intersect(coef_b, paste0(match_vars, suffix))
# fuzzy: coef names that start with any match_var or match_var+suffix
fuzzy_matches <- coef_b[sapply(coef_b, function(x) any(vapply(match_vars, function(mv) grepl(paste0("^", mv), x), logical(1))))]
fuzzy_with_suffix <- coef_b[sapply(coef_b, function(x) any(vapply(paste0(match_vars, suffix), function(mv) grepl(paste0("^", mv), x), logical(1))))]
cat("  exact intersect with match_vars:", toString(inter1), "\n")
cat("  exact intersect with match_vars+suffix:", toString(inter2), "\n")
cat("  fuzzy matches (startsWith match_vars):", toString(unique(fuzzy_matches)), "\n")
cat("  fuzzy matches (startsWith match_vars+suffix):", toString(unique(fuzzy_with_suffix)), "\n")
out[[nm]] <- list(coef_names = coef_b, exact = c(inter1, inter2), fuzzy = unique(c(fuzzy_matches, fuzzy_with_suffix)))
}
return(out)
}
# Ë∞ÉÁî®
diag_res <- diagnose_models(model_list, match_vars, suffix = "")
#| label: adver_discriminant with shap values adver
#| echo: false
#| message: true
#| warning: true
model_list <- list(
INTL      = bayes_intl,
INTLDOM   = bayes_intldom,
DOMPROF   = bayes_domprof,
INTLPROF  = bayes_intlprof,
MATCH     = bayes_match
)
results_adver <- run_bayes_shap_all_models(model_list, adver_all, match_vars, suffix = "")
summary_adver_shap <- purrr::imap_dfr(results_adver, ~ tibble::tibble(
Model = .y,
Direction_Match_Rate = .x$summary$Direction_Match_Rate,
Pearson_Correlation   = .x$summary$Pearson_Correlation,
Abs_Correlation       = .x$summary$Abs_Value_Correlation
))
print(summary_adver_shap)
#| label: adver_discriminant with shap values adver
#| echo: false
#| message: true
#| warning: true
model_list <- list(
INTL      = bayes_intl,
INTLDOM   = bayes_intldom,
DOMPROF   = bayes_domprof,
INTLPROF  = bayes_intlprof,
MATCH     = bayes_match
)
results_adver <- run_bayes_shap_all_models(model_list, adver_all, match_vars, suffix = "")
print(results_adver)
summary_adver_shap <- purrr::imap_dfr(results_adver, ~ tibble::tibble(
Model = .y,
Direction_Match_Rate = .x$summary$Direction_Match_Rate,
Pearson_Correlation   = .x$summary$Pearson_Correlation,
Abs_Correlation       = .x$summary$Abs_Value_Correlation
))
print(summary_adver_shap)
